\documentclass{article}
\usepackage{fleqn}
\usepackage{epsf}
\usepackage{aima2e-slides}

\usepackage[landscape]{geometry}

%\usepackage{amsmath}
\usepackage{amssymb}

\newcommand{\mm}{\!\!-\!\!}
\newcommand{\prompt}{$> \ $}
\newcommand{\rep}[1]{\ulcorner #1 \urcorner}

\begin{document}

\begin{huge}
\titleslide{Chapter 2. Data Abstraction \\ (Essentials of Programming Languages)}{Kwanghoon Choi \\ \ \\ Software Languages and Systems Laboratory\\ Chonnam National University}

\sf

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Outline}


This chapter introduces $\cdots$ . 

\blob Specifying Data via Interfaces

\blob Representation Strategies for Data Types

\blob Interfaces for Recursive Data Types

\blob A Tool for Defining Recursive Data Types

\blob Abstract Syntax and Its Representation

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.1 Specifying Data via Interfaces}
Every time we decide to represent a certain set of quantities in a particular way, we are defining a new data type  \al
- whose values are those representations and \al
- whose operations are the procedures manipulating those entities \al

Motivation\al
- The representation of these entities is often complex, so we do 
not want to be concerned with their details. \al 
- We may decide to change the representation of the data. \al
%- We may wish to develop a simple implementation first and then later change to make it efficient \al
- To change the representation of some data, we must be able to locate all parts of a program that are dependent on the representation.

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.1 Specifying Data via Interfaces (cont.)}

Data abstraction:  \al
- a data type = an interface + an implementation \al
- {\it Abstract data type}

A client code is {\it representation-independent} if it only uses the interface.


%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.1 Specifying Data via Interfaces (cont.)}

Notation: the representation of data $v$, $\rep{v}$

A simple example: the (abstract) data type of natural numbers \al
- An interface
\begin{eqnarray*}
\mbox{(zero)} &=& \rep{0} 
\\
\mbox{(is-zero? $\rep{n}$)} & = &
	\left \{
	\begin{array}{l}
	\#t \ \ \ \ \ \ n = 0 \\
	\#f \ \ \ \ \ \ n \not=0
	\end{array}
	\right . 
\\
\mbox{(successor $\rep{n}$)} & = & 
\rep{n+1} \ \ \ \ \ \ (n\geq 0) 
\\
\mbox{(predecessor $\rep{n+1}$)} & = & 
\rep{n} \ \ \ \ \ \ (n\geq 0)  
\end{eqnarray*}

Many possible representations of the interface \al
- Unary representation \al
- Scheme number representation \al
- Bignum representation

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.2 Representation Strategies for Data Types}

Some strategies for representing a data type of environments \al
- In a PL implementation, it associaes each variable with a value  \al
- In a compiler, it associates each variable with a type \al

Variables may be presented in any way so long as we can check two variables for equality. \al

From the next slides, \al
- The environment interface \al
- Data structure representation \al
- Procedural representation 

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{The Environment Interface}

An environment is a function mapping a finite set of variables onto (Scheme) values \al
- $env = \{ (var_1,val1), \cdots, (var_n, valn) \}$. \al
- the value of the variable in {\it env} is called its {\it binding} in {\it env}.

The interface to a data type for environments \al
\begin{eqnarray*}
\mbox{(empty-env)} &=& \rep{\emptyset} 
\\
\mbox{(apply-env \ $\rep{f}$ \ {\it var})} &=& f(var)
\\
\mbox{(extend-env \ {\it var} \ {\it v} \ $\rep{f}$)} &=& \rep{g}
\\
& & \mbox{where} \ g(var_1) =
\left \{
\begin{array}{l}
v \ \ \ \ \ \ \mbox{if} \ var_1=var 
\\
f(var_1) \ \ \ \mbox{otherwise}
\end{array}
\right .
\end{eqnarray*}

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{The Environment Interface (cont.)}

Using the interface, \al
- to build an environment: $env=\{(d,6), \ (x,7), \ (y,8) \}$ \al
\prompt (define env \al
\ \ \ \ \ 	(extend-env `d 6 \al
\ \ \ \ \ \ \ 		(extend-env `y 8 \al
\ \ \ \ \ \ \ \ \			(extend-env `x 7 \al
\ \ \ \ \ \ \ \ \ \ \ 				(extend-env `y 14 \al
\ \ \ \ \ \ \ \ \ \ \  \ \					(empty-env))))) \al \al
- to look up a binding for a variable: $env(d)$ \al
\prompt (apply-env env `d)

\ \\
Constructors and observers of the procedures of the interface \al

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Data Structure Representation}

Every environment can be built by starting with the empty environment 
and applying extend-env $n$ times.

So, every environment can be built by an expression in the following 
grammar:
%\mat{
\begin{eqnarray*}
Env\mm exp & ::= & (empty \mm env)\\
           & ::= & (extend \mm env \ Identifier \ Scheme \mm value \ Env \mm exp)
\end{eqnarray*}
%}
\al
- See an implementation in Figure 2.1

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Procedural Representation}

An alternative representation is to use procedures for environments. \al
- See an implementation in P.40

Every client-code using the environment interface will be 
represent-independent. \al
- One representation can be replaced with the other without affecting
the client code.

cf. {\it defunctionalization} \al
- A transformation of (higher-order) functions or a procedural representation
into data structures or data structure representation

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.3 Interfaces for Recursive Data Types}

A recursive data type for lambda-calculus expressions:
%\mat{
\begin{eqnarray*}
Lc\mm exp 
 & ::= & Identifier \\
 & ::= & (lambda \ ( Identifier ) \ Lc\mm exp) \\
 & ::= & (Lc\mm exp \ Lc\mm exp)
\end{eqnarray*}
%}

What is an interface for the lambda-calculus expressions? 
In other words, what are constructors and observers for them? \al
- cf. Observers (predicates and extractors) \al

Using the interface, write a procedure as \al
- $occurs\mm free \ : \ Sym \ \times \ LcExp \ \rightarrow \ Bool$

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.4 A Tool for Defining Recursive Data Types}

A tool for automatically constructing and implementing such interfaces
one discussed in Section 2.3 in Scheme: \al
(define-datatype lc-exp lc-exp? \al
\ \ \ (var-exp (var identifier?)) \al
\ \ \ (lambda-exp (bound-var identifier?)) \al
\ \ \ (app-exp (rator lc-exp?) (rand lc-exp?))) \al

Examples: \al
- $x$ : (var-exp `x) \al
- $\lambda x. x$ : (lambda-exp `x (var-exp `x)) \al
- $(lambda x. x) (lambda y.y)$ : \al
\ \ \ \ \ \ \ \ \ (app-exp \al
\ \ \ \ \ \ \ \ \ \ \ \ \ \ (lambda-exp `x (var-exp `x)) \al
\ \ \ \ \ \ \ \ \ \ \ \ \ \ (lambda-exp `y (var-exp `y)))

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.4 A Tool for Defining Rec. Data Types(Cont.)}

A procedure occurs-free? using the interface generated by the tool. \al
- the form ``cases'' to determine the variant to which an object of a data type 
belongs and to extract its components. \al
(define occurs-free? \al
\ \ \ (lambda (search-var exp) \al
\ \ \ \ \ \ (cases lc-exp exp \al
\ \ \ \ \ \ \ \ \ (var-exp (var) (eqv? var search-var)) \al
\ \ \ \ \ \ \ \ \ (lambda-exp (bound-var body) \al
\ \ \ \ \ \ \ \ \ \ \ \ (and \al
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (not (eqv? search-var bound-var)) \al
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (occurs-free? search-var body))) \al
\ \ \ \ \ \ \ \ \ (app-exp (rator rand) \al
\ \ \ \ \ \ \ \ \ \ \ \ (or \al
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (occurs-free? search-var rator) \al
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (occurs-free? search-var rand))))))

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.4 A Tool for Defining Rec. Data Types(Cont.)}

See the textbook (P.47 and P.49) for the general form define-datatype
declaration and the general syntax of cases. \al

The form ``define-datatype'' is an example of a {\it domain-specific 
language (DSL)}. \al
- A DSL is a small language for describing a single task among a small,
well-defined set of tasks.  \al
- Such a language may lie inside a general-purpose language, 
as define-datatype does, or 
it may be a standalone language with its own set of tools. 

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{2.5 Abstract Syntax and Its Representation}

Concrete syntax (defined by a grammar) vs. 
Abstract syntax (by define-datatype) \al
- The concrete syntax is an external representation for humans \al
- The abstract syntax is an internal one for computers \al
- See Figure 2.2 for a comparison

Parsing is a task to derving the corresponding abstract syntax tree from
the concrete syntax which is a sequence of characters. \al
- Parser \al
- Parser generator \al
- $parse\mm expression : SchemeVal \rightarrow LcExp$

The reverse task of parsing is called unparsing or ``pretty-printing''. \al
- Unparser or pretty-printer \al
- $unparse\mm lc\mm exp : LcExp \rightarrow SchemeVal$

\end{huge}
\end{document}

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Inductive Specification}

[Example] A top-down style inductive specification:\al\al
A natural number $n$ is in $S$ if and only if\al
\ \ \ 1. $n=0$ or\al
\ \ \ 2. $n-3 \in S$


%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Inductive Specification (cont.)}

[Example] A bottom-up definition:\al\al
The set $S$ to be the smallest set contained in $N=\{0,1,2,\cdots\}$ and satisfying the following two properties:\al\al
\ \ \ 1. $0 \in S$, and \al
\ \ \ 2. if $n \in S$ then $n + 3 \in S$. 

[Example] Rules of inference:\al\al
The same set $S$ as above \al\al
%\mat{
\begin{tabular}{c}
\phantom{or }\\ \hline
$0 \in S$
\end{tabular}
 \ \ \ 
\begin{tabular}{c}
$n \in S$ \\ \hline
$(n+3) \in S$
\end{tabular}
%}

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Defining Sets Using Grammars}
Grammars\al
- Nonterminal symbols: the names of the sets being defined \al
- Terminal symbols: the characters in the external representation\al
- Production (rule)

Nonterminals = syntactic categories.

[Example]
%\mat{
\begin{eqnarray*}
List\mm of\mm int & ::= & ()\\
                & ::= & (Int \ . \ List\mm of\mm int)
\end{eqnarray*}
%}

cf. Variations of production rules

[Example] $S\mm list$, $S\mm exp$, $Bintree$, $LcExp$

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Defining Sets Using Grammars (cont.)}

The grammars are said to be {\it context-free} because a rule defining a given syntactic category may be applied in any context that makes reference to that syntactic category.

Sometimes we have to look at the context in which the production is applied. Such constraints are called {\it context-sensitive constraints} .\al
- E.g., in many languages every variable must be declared before it is used. 

In practice, the usual approach is first to specify a context-free grammar. Context-sensitive constraints are then added using other methods. 

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{Induction}

We use the inductive definitions in two ways:\al
- to prove theorems about members of the set and\al
- to write programs that manipulate them.

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{1.2 Deriving Recursive Programs}

We have seen that we can analyze an element of an inductively defined set to see how it is built from smaller elements of the set.

We use this idea to define/write a general procedure that compute on inductively defined sets.

When defining a procedure that operates on inductively defined data, the structure of the program should be patterned after the structure of the data.

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{1.2 Deriving Recursive Programs (cont.)}

list-length determines the number of elements in a list: \al
\prompt (list-length `(a b c))\al
3\al
\prompt (list-length `((x) ())\al
2

nth-element picks the n-th element of a list:\al
\prompt (nth-element `(a b c d e) 3)\al
d

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{1.2 Deriving Recursive Programs (cont.)}

remove-first:\al\al
\prompt (remove-first `a `(a b c))\al
(b c)\al
\prompt (remove-first `b `(e f g))\al
(e f g)\al
\prompt (remove-first `a4 `(c1 a4 c1 a4))\al
(c1 c1 a4)\al
\prompt (remove-first `x `())\al
()

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{1.2 Deriving Recursive Programs (cont.)}

The procedure occurs-free? takes a variable {\it var}, and a lambda-calculus expression {\it exp}, and it determines whether or not {\it var} occurs free in {\it exp}. \al\al
\prompt (occurs-free? `x `x) \al
\#t \al
\prompt (occurs-free? `x `y) \al
\#f \al
\prompt (occurs-free? `x `(lambda (x) (x y))) \al
\#f \al
\prompt (occurs-free? `x `((lambda (x) x) (x y))) \al
\#t \al
\prompt (occurs-free? `x `(lambda (y) (lambda (z) (x (y z))))) \al
\#t

%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{1.2 Deriving Recursive Programs (cont.)}

The procedure {\it subst} takes three arguments: two symbols, {\it new} and {\it old}, and an s-list, {\it slist}. All elements of {\it slist} are examined, and a new list is returned that is similar to {\it slist} but with all occurrences of {\it old} replaced by instances of {\it new}.

\prompt (subst `a `b `((b c) (b () d))) \al
((a c) (a () d)


%%%%%%%%%%%% Slide %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\heading{1.3 Auxiliary Procedure and Context Arguments}

Auxiliary procedures\al
- number-elements-from\al
- number-elements\al
- list-sum\al
- partial-vector-sum\al
- vector-sum

\end{huge} 



